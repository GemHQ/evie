// Generated by CoffeeScript 1.9.3
(function() {
  var Attributes, Channel, EventChannel, PatternSet, include, merge, overload, ref, type, w,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = require("fairmont"), include = ref.include, Attributes = ref.Attributes, merge = ref.merge, type = ref.type, w = ref.w;

  Channel = require("./channel");

  PatternSet = require("./pattern-set");

  overload = require("typely").overload;

  EventChannel = (function(superClass) {
    extend(EventChannel, superClass);

    include(EventChannel, Attributes);

    function EventChannel() {
      this.callback = bind(this.callback, this);
      EventChannel.__super__.constructor.apply(this, arguments);
      this.channels = {};
      this._patterns = new PatternSet;
      this.receive((function(_this) {
        return function(message) {
          return _this._patterns.match(message.event, function(event) {
            var ref1;
            return (ref1 = _this.channels[event]) != null ? ref1.fire(message.content) : void 0;
          });
        };
      })(this));
    }

    EventChannel.prototype.on = overload(function(match, fail) {
      match("string", "function", function(name, handler) {
        var base;
        this._patterns.add(name);
        if ((base = this.channels)[name] == null) {
          base[name] = new Channel;
        }
        this.channels[name].receive(handler);
        return this;
      });
      match("object", function(handlers) {
        var handler, name;
        for (name in handlers) {
          handler = handlers[name];
          this.on(name, handler);
        }
        return this;
      });
      return fail(function() {
        throw new TypeError("Invalid event handler specified");
      });
    });

    EventChannel.prototype.once = overload(function(match, fail) {
      match("string", "function", function(name, handler) {
        var _handler;
        _handler = (function(_this) {
          return function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            handler.apply(null, args);
            return _this.remove(name, _handler);
          };
        })(this);
        this.on(name, _handler);
        return this;
      });
      match("object", function(handlers) {
        var handler, name;
        for (name in handlers) {
          handler = handlers[name];
          this.once(name, handler);
        }
        return this;
      });
      return fail(function() {
        throw new TypeError("Invalid event handler specified");
      });
    });

    EventChannel.prototype.success = function(handler) {
      return this.on("success", handler);
    };

    EventChannel.prototype.error = function(handler) {
      return this.on("error", handler);
    };

    EventChannel.prototype.emit = function(name, content) {
      return this.send({
        event: name,
        content: content
      });
    };

    EventChannel.prototype.forward = function(channel, name) {
      return this.receive((function(_this) {
        return function(message) {
          if (name != null) {
            message = merge(message, {
              event: name + "." + message.event
            });
          }
          return channel.fire(message);
        };
      })(this));
    };

    EventChannel.prototype.source = function() {
      var _source;
      _source = function(name, block) {
        var channel;
        channel = new this.constructor;
        channel.forward(this, name);
        if (block != null) {
          block(channel);
        }
        return channel;
      };
      this.source = overload(function(match, fail) {
        match(function() {
          return EventChannel.__super__.source.apply(this, arguments);
        });
        match("function", function(fn) {
          return EventChannel.__super__.source.apply(this, arguments);
        });
        match("string", _source);
        match("string", "function", _source);
        return fail(function() {
          throw new TypeError("Invalid event source specified");
        });
      });
      return this.source.apply(this, arguments);
    };

    EventChannel.prototype.remove = function(event, handler) {
      var ref1;
      return (ref1 = this.channels[event]) != null ? ref1.remove(handler) : void 0;
    };

    EventChannel.prototype.callback = function() {
      var error, results;
      error = arguments[0], results = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (error == null) {
        return this.emit.apply(this, ["success"].concat(slice.call(results)));
      } else {
        return this.emit("error", error);
      }
    };

    EventChannel.prototype.emitter = function(emitter) {
      var emit, self;
      self = this;
      emit = emitter.emit;
      emitter.emit = function() {
        var args, event;
        event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        emit.call.apply(emit, [this, event].concat(slice.call(args)));
        args = (function() {
          switch (args.length) {
            case 0:
              return null;
            case 1:
              return args[0];
            default:
              return args;
          }
        })();
        return self.emit(event, args);
      };
      return emitter;
    };

    EventChannel.prototype.safely = function(fn) {
      var error;
      try {
        return fn();
      } catch (_error) {
        error = _error;
        return this.emit("error", error);
      }
    };

    EventChannel.prototype.serially = function() {
      var accumulate, args, builder, events, functions, go, ref1;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (args.length === 2) {
        (ref1 = args[0], accumulate = ref1.accumulate), builder = args[1];
      } else {
        builder = args[0];
        accumulate = false;
      }
      functions = [];
      go = function(fn) {
        return functions.push(fn);
      };
      builder(go);
      events = this.source();
      return function(arg) {
        var _fn, count, results;
        results = [];
        count = 0;
        _fn = function(arg) {
          var error, fn, result, rval;
          if (arg != null) {
            results.push(arg);
          }
          fn = functions.shift();
          if (fn != null) {
            count++;
            try {
              rval = fn(arg);
              if (rval instanceof EventChannel) {
                rval.on("success", _fn);
                return rval.on("error", function(error) {
                  return events.emit("error", error);
                });
              } else {
                return _fn(rval);
              }
            } catch (_error) {
              error = _error;
              return events.emit("error", error);
            }
          } else {
            if (accumulate === true) {
              return events.emit("success", results);
            } else {
              result = results[results.length - 1];
              return events.emit("success", result);
            }
          }
        };
        _fn(arg);
        return events;
      };
    };

    EventChannel.prototype.concurrently = function(builder) {
      var events, functions, go;
      functions = [];
      go = function(name, fn) {
        return functions.push((fn != null ? [name, fn] : [null, name]));
      };
      builder(go);
      events = this.source();
      return function(arg) {
        var _fn;
        _fn = function(arg) {
          var called, errors, finish, fn, j, len, name, record_error, ref1, results, results1, returned;
          results = {};
          errors = {};
          called = 0;
          returned = 0;
          finish = function() {
            var _error;
            returned++;
            if (called === returned) {
              if (Object.keys(errors).length === 0) {
                return events.emit("success", results);
              } else {
                _error = new Error("concurrently: unable to complete");
                _error.errors = errors;
                return events.emit("error", _error);
              }
            }
          };
          record_error = function(name, _error) {
            if (name) {
              errors[name] = _error;
            } else {
              errors.unnamed_actions || (errors.unnamed_actions = []);
              errors.unnamed_actions.push(_error);
            }
            return finish();
          };
          if (functions.length === 0) {
            return arg;
          }
          results1 = [];
          for (j = 0, len = functions.length; j < len; j++) {
            ref1 = functions[j], name = ref1[0], fn = ref1[1];
            results1.push((function(name, fn) {
              var _error, rval, success;
              success = function(result) {
                if (name != null) {
                  results[name] = result;
                }
                return finish();
              };
              try {
                called++;
                rval = fn(arg);
                if (rval instanceof EventChannel) {
                  rval.on("success", success);
                  return rval.on("error", function(error) {
                    return record_error(name, error);
                  });
                } else {
                  return success(rval);
                }
              } catch (_error) {
                _error = _error;
                return record_error(name, _error);
              }
            })(name, fn));
          }
          return results1;
        };
        _fn(arg);
        return events;
      };
    };

    EventChannel.prototype.wrap = function() {
      var fn, fns, rval;
      fns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      rval = (function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = fns.length; j < len; j++) {
          fn = fns[j];
          results1.push((function(_this) {
            return function() {
              var args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              return _this.source(function(events) {
                var series;
                series = _this.serially({
                  accumulate: true
                }, function(step) {
                  var arg, i, k, len1, results2;
                  results2 = [];
                  for (i = k = 0, len1 = args.length; k < len1; i = ++k) {
                    arg = args[i];
                    results2.push((function(arg) {
                      return step(function() {
                        return arg;
                      });
                    })(arg));
                  }
                  return results2;
                })();
                series.on("error", function(error) {
                  return events.emit("error", error);
                });
                return series.on("success", function(results) {
                  return fn.apply(null, slice.call(results).concat([events.callback]));
                });
              });
            };
          })(this));
        }
        return results1;
      }).call(this);
      if (rval.length < 2) {
        return rval[0];
      } else {
        return rval;
      }
    };

    EventChannel.prototype.sleep = function(ms) {
      return this.source(function(events) {
        return setTimeout((function() {
          return events.emit("success");
        }), ms);
      });
    };

    return EventChannel;

  })(Channel);

  module.exports = EventChannel;

}).call(this);
